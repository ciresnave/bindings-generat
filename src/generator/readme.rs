/// README.md generation for output crates
use crate::analyzer::AnalysisResult;
use std::fmt::Write;

/// Generate README.md content for the output crate
pub fn generate_readme(crate_name: &str, library_name: &str, analysis: &AnalysisResult) -> String {
    let mut readme = String::new();

    // Header
    writeln!(readme, "# {}", crate_name).unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "Safe Rust bindings for {}, automatically generated by [bindings-generat](https://github.com/yourname/bindings-generat).",
        library_name
    )
    .unwrap();
    writeln!(readme).unwrap();

    // Overview
    writeln!(readme, "## Overview").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "This crate provides safe, idiomatic Rust wrappers around the {} C API. It includes:",
        library_name
    )
    .unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "- **Type-safe wrappers** with RAII semantics for automatic resource management"
    )
    .unwrap();
    writeln!(readme, "- **Error handling** using Rust's `Result` type").unwrap();
    writeln!(
        readme,
        "- **Zero-cost abstractions** - wrappers compile down to direct FFI calls"
    )
    .unwrap();
    writeln!(
        readme,
        "- **Comprehensive coverage** of {} functions and types",
        library_name
    )
    .unwrap();
    writeln!(readme).unwrap();

    // Installation
    writeln!(readme, "## Installation").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "Add this to your `Cargo.toml`:").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "```toml").unwrap();
    writeln!(readme, "[dependencies]").unwrap();
    writeln!(readme, "{} = \"0.1.0\"", crate_name).unwrap();
    writeln!(readme, "```").unwrap();
    writeln!(readme).unwrap();

    // Prerequisites
    writeln!(readme, "### Prerequisites").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "{} must be installed on your system:", library_name).unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "- **Headers**: Required at compile time").unwrap();
    writeln!(
        readme,
        "- **Libraries**: Required at both compile and runtime"
    )
    .unwrap();
    writeln!(readme).unwrap();

    // Usage
    writeln!(readme, "## Usage").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "### Basic Example").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "```rust").unwrap();
    writeln!(readme, "use {}::*;", crate_name).unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "fn main() -> Result<(), Error> {{").unwrap();

    // If we have wrappers, show a complete example with lifecycle
    if !analysis.raii_patterns.lifecycle_pairs.is_empty() {
        let first_wrapper = &analysis.raii_patterns.lifecycle_pairs[0];
        let wrapper_name = to_pascal_case(&first_wrapper.handle_type);

        writeln!(
            readme,
            "    // Create a handle (automatically cleaned up when dropped)"
        )
        .unwrap();
        writeln!(readme, "    let mut handle = {}::new()?;", wrapper_name).unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "    // Use the handle - methods are available if the API has them"
        )
        .unwrap();
        writeln!(readme, "    // Example: handle.synchronize()?;").unwrap();
        writeln!(readme, "    // Example: handle.query()?;").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "    // Handle is automatically destroyed when it goes out of scope"
        )
        .unwrap();
    } else {
        writeln!(
            readme,
            "    // Use raw FFI functions - no wrappers generated"
        )
        .unwrap();
        writeln!(readme, "    unsafe {{").unwrap();
        writeln!(readme, "        // Call FFI functions directly").unwrap();
        writeln!(readme, "    }}").unwrap();
    }

    writeln!(readme, "    ").unwrap();
    writeln!(readme, "    Ok(())").unwrap();
    writeln!(readme, "}}").unwrap();
    writeln!(readme, "```").unwrap();
    writeln!(readme).unwrap();

    // RAII Wrappers section (if any)
    if !analysis.raii_patterns.lifecycle_pairs.is_empty() {
        writeln!(readme, "### RAII Wrappers").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "This crate provides safe RAII wrappers for {} handles:",
            library_name
        )
        .unwrap();
        writeln!(readme).unwrap();

        for pair in &analysis.raii_patterns.lifecycle_pairs {
            let wrapper_name = to_pascal_case(&pair.handle_type);
            writeln!(readme, "- `{}` - {}", wrapper_name, pair.handle_type).unwrap();
        }

        writeln!(readme).unwrap();
        writeln!(readme, "Each wrapper:").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "- Calls the appropriate `create` function in `new()`"
        )
        .unwrap();
        writeln!(
            readme,
            "- Implements `Drop` to call the corresponding `destroy` function"
        )
        .unwrap();
        writeln!(readme, "- Prevents use-after-free bugs").unwrap();
        writeln!(readme, "- Ensures resources are always cleaned up").unwrap();
        writeln!(readme).unwrap();

        // Add methods section
        writeln!(readme, "### Methods").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "Wrappers provide safe methods for operations on handles. Methods are generated for functions that take the handle as their first parameter (excluding create/destroy functions)."
        )
        .unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "```rust").unwrap();
        let example_wrapper =
            to_pascal_case(&analysis.raii_patterns.lifecycle_pairs[0].handle_type);
        writeln!(readme, "let mut handle = {}::new()?;", example_wrapper).unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "// Safe method calls (if available in the API):").unwrap();
        writeln!(readme, "// handle.synchronize()?;").unwrap();
        writeln!(readme, "// handle.query(some_param)?;").unwrap();
        writeln!(readme, "// handle.set_attribute(value)?;").unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "// Methods automatically handle:").unwrap();
        writeln!(readme, "// - Passing the handle as the first parameter").unwrap();
        writeln!(readme, "// - Error checking of return values").unwrap();
        writeln!(
            readme,
            "// - Converting Rust types to C types (e.g., String to CString)"
        )
        .unwrap();
        writeln!(readme, "```").unwrap();
        writeln!(readme).unwrap();
    }

    // Error Handling
    writeln!(readme, "### Error Handling").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "All fallible operations return `Result<T, Error>`:").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "```rust").unwrap();
    writeln!(readme, "match some_operation() {{").unwrap();
    writeln!(
        readme,
        "    Ok(result) => println!(\"Success: {{:?}}\", result),"
    )
    .unwrap();
    writeln!(readme, "    Err(e) => eprintln!(\"Error: {{}}\", e),").unwrap();
    writeln!(readme, "}}").unwrap();
    writeln!(readme, "```").unwrap();
    writeln!(readme).unwrap();

    // Add complete lifecycle example
    if !analysis.raii_patterns.lifecycle_pairs.is_empty() {
        writeln!(readme, "### Complete Lifecycle Example").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "Here's a complete example showing the lifecycle of a handle:"
        )
        .unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "```rust").unwrap();
        writeln!(readme, "use {}::*;", crate_name).unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "fn process_data() -> Result<(), Error> {{").unwrap();
        let example_wrapper =
            to_pascal_case(&analysis.raii_patterns.lifecycle_pairs[0].handle_type);
        writeln!(
            readme,
            "    // 1. Creation - calls the create/init function"
        )
        .unwrap();
        writeln!(readme, "    let mut handle = {}::new()?;", example_wrapper).unwrap();
        writeln!(readme).unwrap();
        writeln!(readme, "    // 2. Usage - call methods on the handle").unwrap();
        writeln!(
            readme,
            "    // All methods return Result<T, Error> for error handling"
        )
        .unwrap();
        writeln!(readme, "    // handle.some_operation()?;").unwrap();
        writeln!(readme).unwrap();
        writeln!(
            readme,
            "    // 3. Cleanup - automatic when handle goes out of scope"
        )
        .unwrap();
        writeln!(
            readme,
            "    // The Drop implementation calls the destroy/cleanup function"
        )
        .unwrap();
        writeln!(readme, "    Ok(())").unwrap();
        writeln!(readme, "    // handle is destroyed here automatically").unwrap();
        writeln!(readme, "}}").unwrap();
        writeln!(readme, "```").unwrap();
        writeln!(readme).unwrap();
    }

    // Direct FFI Access
    writeln!(readme, "### Direct FFI Access").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "For advanced use cases, you can access the raw FFI functions:"
    )
    .unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "```rust").unwrap();
    writeln!(readme, "use {}::ffi;", crate_name).unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "unsafe {{").unwrap();
    writeln!(readme, "    // Call raw FFI functions directly").unwrap();
    writeln!(readme, "    ffi::some_function(/* ... */);").unwrap();
    writeln!(readme, "}}").unwrap();
    writeln!(readme, "```").unwrap();
    writeln!(readme).unwrap();

    // Architecture
    writeln!(readme, "## Architecture").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "```text").unwrap();
    writeln!(readme, "{}/", crate_name).unwrap();
    writeln!(readme, "├── src/").unwrap();
    writeln!(
        readme,
        "│   └── lib.rs          # Generated bindings with safe wrappers"
    )
    .unwrap();
    writeln!(readme, "├── build.rs            # Build script for linking").unwrap();
    writeln!(readme, "└── Cargo.toml").unwrap();
    writeln!(readme, "```").unwrap();
    writeln!(readme).unwrap();

    // Code Organization
    writeln!(readme, "### Code Organization").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "- **`pub mod ffi`** - Raw FFI bindings generated by bindgen"
    )
    .unwrap();
    writeln!(
        readme,
        "- **Safe wrappers** - High-level types with RAII semantics"
    )
    .unwrap();
    writeln!(readme, "- **`Error` enum** - Unified error type").unwrap();
    writeln!(readme).unwrap();

    // Statistics
    writeln!(readme, "## Statistics").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "- **RAII Wrappers**: {}",
        analysis.raii_patterns.lifecycle_pairs.len()
    )
    .unwrap();
    writeln!(
        readme,
        "- **Error Enums**: {}",
        analysis.error_patterns.error_enums.len()
    )
    .unwrap();
    writeln!(readme).unwrap();

    // License
    writeln!(readme, "## License").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "Licensed under either of:").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE))"
    )
    .unwrap();
    writeln!(readme, "- MIT license ([LICENSE-MIT](LICENSE-MIT))").unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "at your option.").unwrap();
    writeln!(readme).unwrap();

    // Acknowledgments
    writeln!(readme, "## Acknowledgments").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "These bindings were automatically generated using [bindings-generat](https://github.com/yourname/bindings-generat), which analyzes C libraries and creates safe, idiomatic Rust wrappers."
    )
    .unwrap();
    writeln!(readme).unwrap();
    writeln!(readme, "---").unwrap();
    writeln!(readme).unwrap();
    writeln!(
        readme,
        "**Note**: This crate is automatically generated. If you find issues, please report them to the [bindings-generat](https://github.com/yourname/bindings-generat/issues) project."
    )
    .unwrap();

    readme
}

/// Convert snake_case to PascalCase
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
