// Advanced documentation generation for generated bindings
// Generates comprehensive guides, migration documentation, and safety analyses

use crate::config::GeneratorConfig;
use crate::ffi::parser::{FfiFunction, FfiInfo};
use std::collections::{HashMap, HashSet};

/// Documentation generation options
#[derive(Debug, Clone)]
pub struct DocumentationConfig {
    /// Include migration guide from raw FFI
    pub include_migration_guide: bool,
    /// Include cookbook with common patterns
    pub include_cookbook: bool,
    /// Include safety analysis documentation
    pub include_safety_analysis: bool,
    /// Include performance considerations
    pub include_performance: bool,
    /// Include troubleshooting section
    pub include_troubleshooting: bool,
}

impl Default for DocumentationConfig {
    fn default() -> Self {
        Self {
            include_migration_guide: true,
            include_cookbook: true,
            include_safety_analysis: true,
            include_performance: true,
            include_troubleshooting: true,
        }
    }
}

/// Generate comprehensive documentation for generated bindings
pub fn generate_documentation(ffi_info: &FfiInfo, config: &GeneratorConfig) -> String {
    let doc_config = DocumentationConfig::default();
    let mut docs = String::new();

    // Extract crate name from lib_name or output path
    let crate_name = config.lib_name.as_deref().unwrap_or("generated_bindings");
    let crate_version = "0.1.0"; // Default version

    // Main README header
    docs.push_str(&format!("# {} - Safe Rust Bindings\n\n", crate_name));
    docs.push_str(&format!("Version: {}\n\n", crate_version));
    docs.push_str("Safe, idiomatic Rust bindings generated by bindings-generat.\n\n");

    // Table of contents
    docs.push_str("## Table of Contents\n\n");
    docs.push_str("- [Quick Start](#quick-start)\n");
    docs.push_str("- [Features](#features)\n");
    if doc_config.include_migration_guide {
        docs.push_str("- [Migration Guide](#migration-guide)\n");
    }
    if doc_config.include_cookbook {
        docs.push_str("- [Cookbook](#cookbook)\n");
    }
    if doc_config.include_safety_analysis {
        docs.push_str("- [Safety Analysis](#safety-analysis)\n");
    }
    if doc_config.include_performance {
        docs.push_str("- [Performance Considerations](#performance-considerations)\n");
    }
    if doc_config.include_troubleshooting {
        docs.push_str("- [Troubleshooting](#troubleshooting)\n");
    }
    docs.push_str("- [API Reference](#api-reference)\n\n");

    // Quick start section
    docs.push_str(&generate_quick_start(ffi_info, config));

    // Features section
    docs.push_str(&generate_features_section(config));

    // Optional sections
    if doc_config.include_migration_guide {
        docs.push_str(&generate_migration_guide(ffi_info, config));
    }

    if doc_config.include_cookbook {
        docs.push_str(&generate_cookbook(ffi_info, config));
    }

    if doc_config.include_safety_analysis {
        docs.push_str(&generate_safety_analysis(ffi_info, config));
    }

    if doc_config.include_performance {
        docs.push_str(&generate_performance_section(ffi_info, config));
    }

    if doc_config.include_troubleshooting {
        docs.push_str(&generate_troubleshooting_section(ffi_info));
    }

    // API reference
    docs.push_str(&generate_api_reference(ffi_info));

    docs
}

/// Generate quick start guide
fn generate_quick_start(ffi_info: &FfiInfo, config: &GeneratorConfig) -> String {
    let mut quick_start = String::new();
    let crate_name = config.lib_name.as_deref().unwrap_or("generated_bindings");
    let crate_version = "0.1.0";
    
    quick_start.push_str("## Quick Start\n\n");
    quick_start.push_str("### Installation\n\n");
    quick_start.push_str("Add this to your `Cargo.toml`:\n\n");
    quick_start.push_str("```toml\n");
    quick_start.push_str(&format!("[dependencies]\n{} = \"{}\"\n", crate_name, crate_version));
    quick_start.push_str("```\n\n");

    // Find a good example function for quick start
    if let Some(example_fn) = find_example_function(&ffi_info.functions) {
        quick_start.push_str("### Basic Usage\n\n");
        quick_start.push_str("```rust\n");
        quick_start.push_str(&format!("use {}::*;\n\n", crate_name));
        quick_start.push_str(&generate_usage_example(example_fn));
        quick_start.push_str("```\n\n");
    }

    quick_start
}

/// Generate features section
fn generate_features_section(config: &GeneratorConfig) -> String {
    let mut features = String::new();
    let crate_name = config.lib_name.as_deref().unwrap_or("generated_bindings");
    let crate_version = "0.1.0";
    
    features.push_str("## Features\n\n");
    features.push_str("### Safety Modes\n\n");
    features.push_str("Choose your safety/performance tradeoff:\n\n");
    features.push_str("- **`balanced`** (default): Practical safety with minimal overhead (<1%)\n");
    features.push_str("  - Validates required parameters\n");
    features.push_str("  - Debug assertions for all preconditions\n");
    features.push_str("  - Recommended for most applications\n\n");
    features.push_str("- **`strict`**: Maximum safety (5-10% overhead)\n");
    features.push_str("  - Validates all parameters in release builds\n");
    features.push_str("  - Additional alignment and range checks\n");
    features.push_str("  - Recommended for critical systems\n\n");
    features.push_str("- **`permissive`**: Zero-cost abstractions\n");
    features.push_str("  - No runtime checks (except debug assertions)\n");
    features.push_str("  - Trust caller semantics\n");
    features.push_str("  - Recommended for performance-critical paths\n\n");

    features.push_str("### Optional Features\n\n");
    features.push_str("- **`tracing`**: Performance monitoring with tracing spans\n");
    features.push_str("- **`debug-extra`**: Enhanced debug assertions and logging\n");
    features.push_str("- **`leak-detector`**: Track allocations and detect leaks\n\n");

    features.push_str("### Configuration Example\n\n");
    features.push_str("```toml\n");
    features.push_str(&format!("[dependencies.{}]\n", crate_name));
    features.push_str(&format!("version = \"{}\"\n", crate_version));
    features.push_str("default-features = false\n");
    features.push_str("features = [\"strict\", \"tracing\"]\n");
    features.push_str("```\n\n");

    features
}

/// Generate migration guide from raw FFI
fn generate_migration_guide(ffi_info: &FfiInfo, config: &GeneratorConfig) -> String {
    let mut guide = String::new();
    
    guide.push_str("## Migration Guide\n\n");
    guide.push_str("### From Raw FFI to Safe Bindings\n\n");
    guide.push_str("This guide shows how to migrate from unsafe FFI code to safe bindings.\n\n");

    // Find a function with interesting patterns
    if let Some(example_fn) = find_migration_example(&ffi_info.functions) {
        guide.push_str("#### Example: Before (Raw FFI)\n\n");
        guide.push_str("```rust\n");
        guide.push_str(&generate_raw_ffi_example(example_fn));
        guide.push_str("```\n\n");

        guide.push_str("#### Example: After (Safe Bindings)\n\n");
        guide.push_str("```rust\n");
        guide.push_str(&generate_safe_binding_example(example_fn));
        guide.push_str("```\n\n");

        guide.push_str("### Key Improvements\n\n");
        guide.push_str("1. **Type Safety**: Raw pointers replaced with typed references\n");
        guide.push_str("2. **Null Safety**: Automatic null checks with descriptive errors\n");
        guide.push_str("3. **Resource Management**: RAII types handle cleanup automatically\n");
        guide.push_str("4. **Error Handling**: C error codes converted to Rust `Result` types\n");
        guide.push_str("5. **Documentation**: Rich inline docs with examples and safety notes\n\n");
    }

    guide
}

/// Generate cookbook with common patterns
fn generate_cookbook(ffi_info: &FfiInfo, config: &GeneratorConfig) -> String {
    let mut cookbook = String::new();
    let crate_name = config.lib_name.as_deref().unwrap_or("generated_bindings");
    
    cookbook.push_str("## Cookbook\n\n");
    cookbook.push_str("Common patterns and recipes for working with these bindings.\n\n");

    // Pattern 1: Handle lifecycle management
    cookbook.push_str("### Pattern: Handle Lifecycle\n\n");
    cookbook.push_str("```rust\n");
    cookbook.push_str(&format!("use {}::*;\n\n", crate_name));
    cookbook.push_str("fn example() -> Result<(), Error> {\n");
    cookbook.push_str("    // Handles are automatically cleaned up via Drop\n");
    cookbook.push_str("    let handle = create_handle()?;\n");
    cookbook.push_str("    \n");
    cookbook.push_str("    // Use the handle\n");
    cookbook.push_str("    configure_handle(&handle)?;\n");
    cookbook.push_str("    \n");
    cookbook.push_str("    // Cleanup happens automatically\n");
    cookbook.push_str("    Ok(())\n");
    cookbook.push_str("} // handle dropped here\n");
    cookbook.push_str("```\n\n");

    // Pattern 2: Error handling
    cookbook.push_str("### Pattern: Error Handling\n\n");
    cookbook.push_str("```rust\n");
    cookbook.push_str("match some_operation() {\n");
    cookbook.push_str("    Ok(result) => println!(\"Success: {:?}\", result),\n");
    cookbook.push_str("    Err(Error::InvalidArgument(msg)) => eprintln!(\"Invalid: {}\", msg),\n");
    cookbook.push_str("    Err(Error::InternalError(msg)) => eprintln!(\"Internal: {}\", msg),\n");
    cookbook.push_str("    Err(e) => eprintln!(\"Other error: {}\", e),\n");
    cookbook.push_str("}\n");
    cookbook.push_str("```\n\n");

    // Pattern 3: Performance optimization
    cookbook.push_str("### Pattern: Performance-Critical Sections\n\n");
    cookbook.push_str("For maximum performance, use permissive mode for hot paths:\n\n");
    cookbook.push_str("```rust\n");
    cookbook.push_str("#[cfg(feature = \"permissive\")]\n");
    cookbook.push_str("fn fast_path(data: &[u8]) -> Result<(), Error> {\n");
    cookbook.push_str("    // Zero overhead - caller must ensure invariants\n");
    cookbook.push_str("    unsafe_operation(data)\n");
    cookbook.push_str("}\n\n");
    cookbook.push_str("#[cfg(not(feature = \"permissive\"))]\n");
    cookbook.push_str("fn fast_path(data: &[u8]) -> Result<(), Error> {\n");
    cookbook.push_str("    // Safety checks enabled\n");
    cookbook.push_str("    safe_operation(data)\n");
    cookbook.push_str("}\n");
    cookbook.push_str("```\n\n");

    // Pattern 4: Thread safety
    if has_thread_safety_concerns(ffi_info) {
        cookbook.push_str("### Pattern: Thread Safety\n\n");
        cookbook.push_str("```rust\n");
        cookbook.push_str("use std::sync::Arc;\n\n");
        cookbook.push_str("// Handles are Send + Sync when safe\n");
        cookbook.push_str("let handle = Arc::new(create_handle()?);\n");
        cookbook.push_str("let handle_clone = Arc::clone(&handle);\n\n");
        cookbook.push_str("std::thread::spawn(move || {\n");
        cookbook.push_str("    // Use handle in another thread\n");
        cookbook.push_str("    use_handle(&handle_clone).ok();\n");
        cookbook.push_str("});\n");
        cookbook.push_str("```\n\n");
    }

    cookbook
}

/// Generate safety analysis documentation
fn generate_safety_analysis(ffi_info: &FfiInfo, _config: &GeneratorConfig) -> String {
    let mut analysis = String::new();
    
    analysis.push_str("## Safety Analysis\n\n");
    analysis.push_str("This section documents the safety guarantees and potential risks.\n\n");

    // Analyze unsafe operations
    let unsafe_count = count_unsafe_operations(&ffi_info.functions);
    analysis.push_str(&format!("### Unsafe Operations: {}\n\n", unsafe_count));

    if unsafe_count > 0 {
        analysis.push_str("All unsafe operations are:\n\n");
        analysis.push_str("1. **Documented**: Each unsafe block has a SAFETY comment\n");
        analysis.push_str("2. **Minimized**: Unsafe scope is as small as possible\n");
        analysis.push_str("3. **Validated**: Preconditions checked before unsafe calls\n");
        analysis.push_str("4. **Tested**: Property-based tests verify invariants\n\n");
    }

    // Document null pointer handling
    analysis.push_str("### Null Pointer Safety\n\n");
    analysis.push_str("- **Strict mode**: All pointers validated\n");
    analysis.push_str("- **Balanced mode**: Required pointers validated\n");
    analysis.push_str("- **Permissive mode**: No runtime checks (debug assertions only)\n\n");

    // Document memory safety
    analysis.push_str("### Memory Safety\n\n");
    analysis.push_str("- **Ownership**: Clear ownership semantics via RAII types\n");
    analysis.push_str("- **Lifetimes**: Borrowing rules prevent use-after-free\n");
    analysis.push_str("- **Leak Detection**: Optional leak-detector feature tracks allocations\n\n");

    // Document thread safety
    analysis.push_str("### Thread Safety\n\n");
    if has_thread_safety_concerns(ffi_info) {
        analysis.push_str("⚠️ Some types are NOT thread-safe:\n\n");
        analysis.push_str("- Check individual type documentation for Send/Sync bounds\n");
        analysis.push_str("- Use synchronization primitives when sharing across threads\n\n");
    } else {
        analysis.push_str("✅ All types are thread-safe (Send + Sync)\n\n");
    }

    analysis
}

/// Generate performance considerations section
fn generate_performance_section(ffi_info: &FfiInfo, _config: &GeneratorConfig) -> String {
    let mut perf = String::new();
    
    perf.push_str("## Performance Considerations\n\n");

    perf.push_str("### Safety Mode Overhead\n\n");
    perf.push_str("| Mode | Typical Overhead | Use Case |\n");
    perf.push_str("|------|------------------|----------|\n");
    perf.push_str("| Permissive | 0% | Hot paths, trusted callers |\n");
    perf.push_str("| Balanced | <1% | General purpose (default) |\n");
    perf.push_str("| Strict | 5-10% | Critical systems, untrusted input |\n\n");

    perf.push_str("### Optimization Tips\n\n");
    perf.push_str("1. **Batch Operations**: Group multiple FFI calls to reduce overhead\n");
    perf.push_str("2. **Feature Flags**: Disable unused features (tracing, leak-detector)\n");
    perf.push_str("3. **Profile First**: Use `tracing` feature to identify bottlenecks\n");
    perf.push_str("4. **Selective Permissive**: Use permissive mode only for verified hot paths\n\n");

    // Analyze function call patterns
    let total_functions = ffi_info.functions.len();
    perf.push_str(&format!("### FFI Call Overhead\n\n"));
    perf.push_str(&format!("This crate wraps {} FFI functions. Each call has:\n\n", total_functions));
    perf.push_str("- **Balanced mode**: 1-2 conditional branches per parameter\n");
    perf.push_str("- **Strict mode**: 2-4 conditional branches per parameter\n");
    perf.push_str("- **Permissive mode**: Zero branches (direct FFI call)\n\n");

    perf.push_str("Debug assertions are compiled out in release builds (all modes).\n\n");

    perf
}

/// Generate troubleshooting section
fn generate_troubleshooting_section(ffi_info: &FfiInfo) -> String {
    let mut trouble = String::new();
    
    trouble.push_str("## Troubleshooting\n\n");

    trouble.push_str("### Common Issues\n\n");
    trouble.push_str("#### Null Pointer Errors\n\n");
    trouble.push_str("```\n");
    trouble.push_str("Error: InvalidArgument(\"parameter 'ptr' cannot be null\")\n");
    trouble.push_str("```\n\n");
    trouble.push_str("**Solution**: Ensure all required parameters are non-null. Check API documentation.\n\n");

    trouble.push_str("#### Range Validation Errors\n\n");
    trouble.push_str("```\n");
    trouble.push_str("Error: InvalidArgument(\"parameter 'size' must be in range [1, 1024]\")\n");
    trouble.push_str("```\n\n");
    trouble.push_str("**Solution**: Verify parameter values are within documented constraints.\n\n");

    trouble.push_str("#### Handle Lifetime Errors\n\n");
    trouble.push_str("```\n");
    trouble.push_str("error[E0505]: cannot move out of `handle` because it is borrowed\n");
    trouble.push_str("```\n\n");
    trouble.push_str("**Solution**: Clone the handle or restructure to avoid moving borrowed values.\n\n");

    trouble.push_str("### Debugging Tips\n\n");
    trouble.push_str("1. **Enable tracing**: Add `features = [\"tracing\"]` to see FFI call traces\n");
    trouble.push_str("2. **Use strict mode**: Add `features = [\"strict\"]` for maximum validation\n");
    trouble.push_str("3. **Check debug assertions**: Run tests in debug mode to catch violations\n");
    trouble.push_str("4. **Enable leak detection**: Add `features = [\"leak-detector\"]` to find leaks\n\n");

    trouble.push_str("### Getting Help\n\n");
    trouble.push_str("- Check the [API Reference](#api-reference) for detailed function documentation\n");
    trouble.push_str("- Review the [Safety Analysis](#safety-analysis) for safety guarantees\n");
    trouble.push_str("- See the [Cookbook](#cookbook) for common usage patterns\n\n");

    trouble
}

/// Generate API reference section
fn generate_api_reference(ffi_info: &FfiInfo) -> String {
    let mut reference = String::new();
    
    reference.push_str("## API Reference\n\n");
    reference.push_str("For complete API documentation, run:\n\n");
    reference.push_str("```bash\n");
    reference.push_str("cargo doc --open\n");
    reference.push_str("```\n\n");

    // Group functions by module/prefix
    let grouped = group_functions_by_prefix(&ffi_info.functions);
    
    reference.push_str("### Function Groups\n\n");
    for (prefix, functions) in grouped {
        reference.push_str(&format!("#### {} ({} functions)\n\n", prefix, functions.len()));
        for func in functions.iter().take(5) {
            reference.push_str(&format!("- `{}`\n", func.name));
        }
        if functions.len() > 5 {
            reference.push_str(&format!("- ... and {} more\n", functions.len() - 5));
        }
        reference.push_str("\n");
    }

    reference
}

/// Find a good example function for quick start
fn find_example_function(functions: &[FfiFunction]) -> Option<&FfiFunction> {
    // Prefer "create" or "init" functions
    functions.iter().find(|f| {
        let name_lower = f.name.to_lowercase();
        name_lower.contains("create") || name_lower.contains("init") || name_lower.contains("new")
    }).or_else(|| functions.first())
}

/// Find a good example for migration guide
fn find_migration_example(functions: &[FfiFunction]) -> Option<&FfiFunction> {
    // Prefer functions with interesting patterns (multiple params, return values)
    functions.iter().find(|f| {
        !f.params.is_empty() && !f.return_type.as_str().contains("void")
    }).or_else(|| functions.first())
}

/// Generate usage example for a function
fn generate_usage_example(func: &FfiFunction) -> String {
    let mut example = String::new();
    
    example.push_str("fn example() -> Result<(), Error> {\n");
    example.push_str(&format!("    // Call {}\n", func.name));
    
    // Generate simple example call
    if func.name.to_lowercase().contains("create") || func.name.to_lowercase().contains("init") {
        example.push_str(&format!("    let result = {}()?;\n", to_snake_case(&func.name)));
        example.push_str("    println!(\"Created successfully: {:?}\", result);\n");
    } else {
        example.push_str(&format!("    {}()?;\n", to_snake_case(&func.name)));
        example.push_str("    println!(\"Operation completed successfully\");\n");
    }
    
    example.push_str("    Ok(())\n");
    example.push_str("}\n");
    
    example
}

/// Generate raw FFI example
fn generate_raw_ffi_example(func: &FfiFunction) -> String {
    let mut example = String::new();
    
    example.push_str("unsafe {\n");
    example.push_str("    // Manual null checks\n");
    example.push_str("    let ptr = std::ptr::null_mut();\n");
    example.push_str("    if ptr.is_null() {\n");
    example.push_str("        return Err(\"Null pointer\");\n");
    example.push_str("    }\n\n");
    example.push_str("    // Manual error handling\n");
    example.push_str(&format!("    let status = {}(ptr);\n", func.name));
    example.push_str("    if status != 0 {\n");
    example.push_str("        return Err(\"FFI call failed\");\n");
    example.push_str("    }\n\n");
    example.push_str("    // Manual cleanup\n");
    example.push_str("    // ... (easy to forget!)\n");
    example.push_str("}\n");
    
    example
}

/// Generate safe binding example
fn generate_safe_binding_example(func: &FfiFunction) -> String {
    let mut example = String::new();
    
    example.push_str("// No unsafe blocks needed!\n");
    example.push_str(&format!("let result = {}()?;\n\n", to_snake_case(&func.name)));
    example.push_str("// Null checks automatic\n");
    example.push_str("// Error handling via Result\n");
    example.push_str("// Cleanup via Drop trait\n");
    
    example
}

/// Count unsafe operations in functions
fn count_unsafe_operations(functions: &[FfiFunction]) -> usize {
    // Each FFI call is technically unsafe
    functions.len()
}

/// Check if there are thread safety concerns
fn has_thread_safety_concerns(ffi_info: &FfiInfo) -> bool {
    // Check if any types are marked as not thread-safe
    ffi_info.opaque_types.iter().any(|t| {
        // Heuristic: types with "context" or "state" may not be thread-safe
        let name_lower = t.to_lowercase();
        name_lower.contains("context") || name_lower.contains("state")
    })
}

/// Group functions by common prefix
fn group_functions_by_prefix(functions: &[FfiFunction]) -> Vec<(String, Vec<&FfiFunction>)> {
    let mut groups: HashMap<String, Vec<&FfiFunction>> = HashMap::new();
    
    for func in functions {
        let prefix = extract_prefix(&func.name);
        groups.entry(prefix).or_default().push(func);
    }
    
    let mut sorted: Vec<_> = groups.into_iter().collect();
    sorted.sort_by(|a, b| b.1.len().cmp(&a.1.len()));
    sorted
}

/// Extract common prefix from function name
fn extract_prefix(name: &str) -> String {
    // Find first uppercase letter after the start
    if let Some(pos) = name.chars().skip(1).position(|c| c.is_uppercase()) {
        name[..pos + 1].to_string()
    } else {
        name.to_string()
    }
}

/// Convert to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_is_upper = false;
    
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 && !prev_is_upper {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
            prev_is_upper = true;
        } else {
            result.push(c);
            prev_is_upper = false;
        }
    }
    
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("cudnnCreate"), "cudnn_create");
        assert_eq!(to_snake_case("setTensor4d"), "set_tensor4d");
        assert_eq!(to_snake_case("GetStatus"), "get_status");
    }

    #[test]
    fn test_extract_prefix() {
        assert_eq!(extract_prefix("cudnnCreate"), "cudnn");
        assert_eq!(extract_prefix("tensorSet"), "tensor");
        assert_eq!(extract_prefix("simple"), "simple");
    }

    #[test]
    fn test_documentation_config_default() {
        let config = DocumentationConfig::default();
        assert!(config.include_migration_guide);
        assert!(config.include_cookbook);
        assert!(config.include_safety_analysis);
    }

    #[test]
    fn test_count_unsafe_operations() {
        let functions = vec![
            FfiFunction {
                name: "test1".to_string(),
                return_type: "int".to_string(),
                params: vec![],
                docs: None,
            },
            FfiFunction {
                name: "test2".to_string(),
                return_type: "void".to_string(),
                params: vec![],
                docs: None,
            },
        ];
        
        assert_eq!(count_unsafe_operations(&functions), 2);
    }

    #[test]
    fn test_group_functions_by_prefix() {
        let functions = vec![
            FfiFunction {
                name: "cudnnCreate".to_string(),
                return_type: "int".to_string(),
                params: vec![],
                docs: None,
            },
            FfiFunction {
                name: "cudnnDestroy".to_string(),
                return_type: "void".to_string(),
                params: vec![],
                docs: None,
            },
            FfiFunction {
                name: "tensorSet".to_string(),
                return_type: "int".to_string(),
                params: vec![],
                docs: None,
            },
        ];
        
        let groups = group_functions_by_prefix(&functions);
        assert_eq!(groups.len(), 2);
        
        // cudnn prefix should have 2 functions
        let cudnn_group = groups.iter().find(|(prefix, _)| prefix == "cudnn").unwrap();
        assert_eq!(cudnn_group.1.len(), 2);
    }
}
