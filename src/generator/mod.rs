pub mod builders;
pub mod errors;
pub mod methods;
pub mod templates;
pub mod wrappers;

use crate::analyzer::AnalysisResult;
use crate::ffi::FfiInfo;
use anyhow::Result;
use std::fmt::Write;
use tracing::info;

/// Generated code output
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    pub lib_rs: String,
    pub ffi_bindings: String,
}

/// Generate safe Rust wrapper code from analysis
pub fn generate_code(
    ffi_info: &FfiInfo,
    analysis: &AnalysisResult,
    lib_name: &str,
    enhancements: Option<&crate::llm::CodeEnhancements>,
) -> Result<GeneratedCode> {
    info!("Generating safe Rust wrapper code");

    let mut lib_rs = String::new();

    // Generate header
    generate_header(&mut lib_rs, lib_name);

    // Always generate error enum (even if no error pattern detected)
    if let Some(error_enum) = analysis.error_patterns.error_enums.first() {
        lib_rs.push_str(&errors::generate_error_enum(error_enum, enhancements));
    } else {
        // Generate a basic error type
        lib_rs.push_str(&errors::generate_basic_error());
    }

    // Generate RAII wrappers for handle types with lifecycle pairs
    for pair in &analysis.raii_patterns.lifecycle_pairs {
        if let Some(handle) = analysis
            .raii_patterns
            .handle_types
            .iter()
            .find(|h| h.name == pair.handle_type)
        {
            let wrapper = wrappers::generate_raii_wrapper(handle, pair, lib_name);
            lib_rs.push_str(&wrapper.code);
        }
    }

    // Generate basic wrapper types for handle types WITHOUT lifecycle pairs
    // These don't have Drop implementation, but provide a safe container
    for handle in &analysis.raii_patterns.handle_types {
        // Skip if already generated with lifecycle pair
        if analysis
            .raii_patterns
            .lifecycle_pairs
            .iter()
            .any(|p| p.handle_type == handle.name)
        {
            continue;
        }

        let wrapper = wrappers::generate_basic_wrapper(handle);
        lib_rs.push_str(&wrapper.code);
    }

    // Generate methods for each wrapper
    for handle in &analysis.raii_patterns.handle_types {
        generate_methods_for_handle(&mut lib_rs, handle, ffi_info)?;
    }

    Ok(GeneratedCode {
        lib_rs,
        ffi_bindings: String::new(), // Will be populated with bindgen output
    })
}

fn generate_header(code: &mut String, lib_name: &str) {
    writeln!(code, "//! Safe Rust wrapper for {}", lib_name).unwrap();
    writeln!(code, "//!").unwrap();
    writeln!(
        code,
        "//! This module was automatically generated by bindings-generat."
    )
    .unwrap();
    writeln!(
        code,
        "//! It provides safe, idiomatic Rust wrappers around the raw FFI bindings."
    )
    .unwrap();
    writeln!(code).unwrap();
    writeln!(code, "#![allow(dead_code)]").unwrap();
    writeln!(code, "#![allow(non_camel_case_types)]").unwrap();
    writeln!(code, "#![allow(non_snake_case)]").unwrap();
    writeln!(code, "#![allow(non_upper_case_globals)]").unwrap();
    writeln!(code).unwrap();
    writeln!(code, "// Note: FFI bindings should be in src/ffi.rs").unwrap();
    writeln!(
        code,
        "// Run bindgen on your headers and place the output there"
    )
    .unwrap();
    writeln!(code, "#[path = \"ffi.rs\"]").unwrap();
    writeln!(code, "mod ffi;").unwrap();
    writeln!(code).unwrap();
}

fn generate_methods_for_handle(
    code: &mut String,
    handle: &crate::analyzer::raii::HandleType,
    ffi_info: &FfiInfo,
) -> Result<()> {
    // Find functions that operate on this handle
    let handle_functions: Vec<_> = ffi_info
        .functions
        .iter()
        .filter(|f| {
            // Check if function takes this handle as parameter
            f.params.iter().any(|p| p.ty.contains(&handle.name))
        })
        .collect();

    if handle_functions.is_empty() {
        return Ok(());
    }

    // Convert handle type name to Rust type name (PascalCase)
    let type_name = wrappers::to_rust_type_name(&handle.name);

    // Collect methods first
    let mut methods = Vec::new();
    for func in handle_functions {
        // Skip create/destroy functions (already handled)
        if handle.create_functions.contains(&func.name)
            || handle.destroy_functions.contains(&func.name)
        {
            continue;
        }

        if let Some(method_code) = methods::generate_safe_method(func, Some(&handle.name)) {
            methods.push(method_code);
        }
    }

    // Only generate impl block if there are methods
    if !methods.is_empty() {
        writeln!(code, "// Additional methods for {}", handle.name).unwrap();
        writeln!(code, "impl {} {{", type_name).unwrap();
        for method_code in methods {
            code.push_str(&method_code);
        }
        writeln!(code, "}}").unwrap();
        writeln!(code).unwrap();
    }

    Ok(())
}
