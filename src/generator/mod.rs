pub mod builders;
pub mod errors;
pub mod methods;
pub mod templates;
pub mod wrappers;

use crate::analyzer::AnalysisResult;
use crate::ffi::FfiInfo;
use anyhow::Result;
use std::fmt::Write;
use tracing::info;

/// Generated code output
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    pub lib_rs: String,
    pub ffi_bindings: String,
}

/// Generate safe Rust wrapper code from analysis
pub fn generate_code(
    ffi_info: &FfiInfo,
    analysis: &AnalysisResult,
    lib_name: &str,
    enhancements: Option<&crate::llm::CodeEnhancements>,
) -> Result<GeneratedCode> {
    info!("Generating safe Rust wrapper code");

    let mut lib_rs = String::new();

    // Generate header (includes FFI module declaration)
    generate_header(&mut lib_rs, lib_name);

    // Collect all FFI types used in generated code
    let ffi_types = collect_ffi_types(ffi_info, analysis);

    // Generate imports for FFI types
    generate_ffi_imports(&mut lib_rs, &ffi_types);

    // Always generate error enum (even if no error pattern detected)
    if let Some(error_enum) = analysis.error_patterns.error_enums.first() {
        lib_rs.push_str(&errors::generate_error_enum(error_enum, enhancements));
    } else {
        // Generate a basic error type
        lib_rs.push_str(&errors::generate_basic_error());
    }

    // Generate RAII wrappers for handle types with lifecycle pairs
    for pair in &analysis.raii_patterns.lifecycle_pairs {
        if let Some(handle) = analysis
            .raii_patterns
            .handle_types
            .iter()
            .find(|h| h.name == pair.handle_type)
        {
            let wrapper = wrappers::generate_raii_wrapper(handle, pair, lib_name);
            lib_rs.push_str(&wrapper.code);
        }
    }

    // Generate basic wrapper types for handle types WITHOUT lifecycle pairs
    // These don't have Drop implementation, but provide a safe container
    for handle in &analysis.raii_patterns.handle_types {
        // Skip if already generated with lifecycle pair
        if analysis
            .raii_patterns
            .lifecycle_pairs
            .iter()
            .any(|p| p.handle_type == handle.name)
        {
            continue;
        }

        let wrapper = wrappers::generate_basic_wrapper(handle);
        lib_rs.push_str(&wrapper.code);
    }

    // Generate methods for each wrapper
    for handle in &analysis.raii_patterns.handle_types {
        generate_methods_for_handle(&mut lib_rs, handle, ffi_info)?;
    }

    Ok(GeneratedCode {
        lib_rs,
        ffi_bindings: String::new(), // Will be populated with bindgen output
    })
}

fn generate_header(code: &mut String, lib_name: &str) {
    writeln!(code, "//! Safe Rust wrapper for {}", lib_name).unwrap();
    writeln!(code, "//!").unwrap();
    writeln!(
        code,
        "//! This module was automatically generated by bindings-generat."
    )
    .unwrap();
    writeln!(
        code,
        "//! It provides safe, idiomatic Rust wrappers around the raw FFI bindings."
    )
    .unwrap();
    writeln!(code).unwrap();
    writeln!(code, "#![allow(dead_code)]").unwrap();
    writeln!(code, "#![allow(non_camel_case_types)]").unwrap();
    writeln!(code, "#![allow(non_snake_case)]").unwrap();
    writeln!(code, "#![allow(non_upper_case_globals)]").unwrap();
    writeln!(code).unwrap();
    writeln!(code, "// Note: FFI bindings should be in src/ffi.rs").unwrap();
    writeln!(
        code,
        "// Run bindgen on your headers and place the output there"
    )
    .unwrap();
    writeln!(code, "#[path = \"ffi.rs\"]").unwrap();
    writeln!(code, "mod ffi;").unwrap();
    writeln!(code).unwrap();
}

/// Collect all FFI types used in generated wrapper code
fn collect_ffi_types(
    ffi_info: &FfiInfo,
    analysis: &AnalysisResult,
) -> std::collections::HashSet<String> {
    use std::collections::HashSet;

    let mut types = HashSet::new();

    // Collect types from functions that operate on handles
    for handle in &analysis.raii_patterns.handle_types {
        let handle_functions: Vec<_> = ffi_info
            .functions
            .iter()
            .filter(|f| f.params.iter().any(|p| p.ty.contains(&handle.name)))
            .collect();

        for func in handle_functions {
            // Add return type if it's an FFI type
            if !func.return_type.is_empty()
                && func.return_type != "()"
                && func.return_type != "c_void"
                && !is_rust_primitive(&func.return_type)
            {
                types.insert(func.return_type.clone());
            }

            // Add parameter types
            for param in &func.params {
                // Extract base type from pointers
                let base_type = param
                    .ty
                    .replace("*const ", "")
                    .replace("*mut ", "")
                    .replace("* const ", "")
                    .replace("* mut ", "")
                    .trim()
                    .to_string();

                if !base_type.is_empty()
                    && !is_rust_primitive(&base_type)
                    && !base_type.contains("::")
                {
                    types.insert(base_type);
                }
            }
        }
    }

    types
}

/// Check if a type is a Rust primitive
fn is_rust_primitive(ty: &str) -> bool {
    matches!(
        ty,
        "i8" | "i16"
            | "i32"
            | "i64"
            | "i128"
            | "isize"
            | "u8"
            | "u16"
            | "u32"
            | "u64"
            | "u128"
            | "usize"
            | "f32"
            | "f64"
            | "bool"
            | "char"
            | "()"
            | "c_void"
            | "c_char"
            | "c_int"
            | "c_uint"
            | "c_long"
            | "c_ulong"
            | "c_short"
            | "c_ushort"
            | "c_longlong"
            | "c_ulonglong"
            | "c_float"
            | "c_double"
    )
}

/// Generate use statements for FFI types
fn generate_ffi_imports(code: &mut String, types: &std::collections::HashSet<String>) {
    if types.is_empty() {
        return;
    }

    writeln!(code, "// Import FFI types used in wrapper code").unwrap();
    let mut sorted_types: Vec<_> = types.iter().collect();
    sorted_types.sort();

    for ty in sorted_types {
        writeln!(code, "use crate::ffi::{};", ty).unwrap();
    }
    writeln!(code).unwrap();
}

fn generate_methods_for_handle(
    code: &mut String,
    handle: &crate::analyzer::raii::HandleType,
    ffi_info: &FfiInfo,
) -> Result<()> {
    // Find functions that operate on this handle
    let handle_functions: Vec<_> = ffi_info
        .functions
        .iter()
        .filter(|f| {
            // Check if function takes this handle as parameter
            f.params.iter().any(|p| p.ty.contains(&handle.name))
        })
        .collect();

    if handle_functions.is_empty() {
        return Ok(());
    }

    // Convert handle type name to Rust type name (PascalCase)
    let type_name = wrappers::to_rust_type_name(&handle.name);

    // Collect methods first
    let mut methods = Vec::new();
    for func in handle_functions {
        // Skip create/destroy functions (already handled)
        if handle.create_functions.contains(&func.name)
            || handle.destroy_functions.contains(&func.name)
        {
            continue;
        }

        if let Some(method_code) = methods::generate_safe_method(func, Some(&handle.name)) {
            methods.push(method_code);
        }
    }

    // Only generate impl block if there are methods
    if !methods.is_empty() {
        writeln!(code, "// Additional methods for {}", handle.name).unwrap();
        writeln!(code, "impl {} {{", type_name).unwrap();
        for method_code in methods {
            code.push_str(&method_code);
        }
        writeln!(code, "}}").unwrap();
        writeln!(code).unwrap();
    }

    Ok(())
}
