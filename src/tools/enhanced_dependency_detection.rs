//! Enhanced dependency detection with multiple pattern sources and intelligent search
//!
//! This system supports:
//! - Multiple pattern sources: hardcoded, learned, LLM-generated, user-provided
//! - Intelligent library searching across system paths
//! - LLM user interaction when patterns don't match
//! - Dynamic pattern creation based on user input
//! - Library validation through symbol checking and compilation testing
//! - User choice when multiple libraries match

use super::{Tool, ToolContext, ToolResult};
use super::pattern_storage::PatternStorage;
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use tracing::{debug, info, warn};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PatternSource {
    /// Built-in patterns for common libraries
    Hardcoded,
    /// Patterns learned from previous successful detections
    Learned,
    /// Patterns generated by LLM analysis
    LlmGenerated,
    /// Patterns provided directly by user
    UserProvided,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DependencyPattern {
    pub name: String,
    pub source: PatternSource,
    pub confidence: f32, // 0.0 to 1.0
    pub function_patterns: Vec<String>,
    pub type_patterns: Vec<String>,
    pub header_indicators: Vec<String>,
    pub env_vars: Vec<String>,
    pub common_paths: Vec<String>,
    pub include_subpaths: Vec<String>,
    pub lib_subpaths: Vec<String>,
    pub link_libs: Vec<String>,
    pub pkg_config_name: Option<String>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub success_count: u32,
    pub failure_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryCandidate {
    pub name: String,
    pub path: PathBuf,
    pub confidence: f32,
    pub found_symbols: Vec<String>,
    pub compilation_test_passed: Option<bool>,
    pub source: String, // How it was found
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DependencyInfo {
    pub name: String,
    pub include_dirs: Vec<PathBuf>,
    pub lib_paths: Vec<PathBuf>,
    pub link_libs: Vec<String>,
    pub pattern_used: Option<DependencyPattern>,
    pub library_candidates: Vec<LibraryCandidate>,
    pub user_choice: Option<LibraryCandidate>,
}

pub struct EnhancedDependencyDetectionTool {
    pattern_storage: PatternStorage,
    llm_client: Option<crate::llm::OllamaClient>,
}

impl EnhancedDependencyDetectionTool {
    pub fn new(cache_dir: Option<PathBuf>) -> Result<Self> {
        Ok(Self {
            pattern_storage: PatternStorage::new(cache_dir.clone())?,
            llm_client: cache_dir.map(|dir| crate::llm::OllamaClient::new(Some(dir))).transpose()?,
        })
    }

    /// Detect dependencies using multiple pattern sources and intelligent search
    pub async fn detect_dependencies(&self, context: &ToolContext) -> Result<Vec<DependencyInfo>> {
        let ffi_info = context.ffi_info.as_ref()
            .ok_or_else(|| anyhow::anyhow!("FFI info not available"))?;

        let mut detected_deps = Vec::new();
        let mut unmatched_functions = Vec::new();

        // Step 1: Try to match functions using existing patterns
        let patterns = self.pattern_storage.get_all_patterns()?;
        let mut matched_functions = HashSet::new();

        for pattern in patterns {
            let matches = self.find_pattern_matches(&pattern, &ffi_info.functions);
            if !matches.is_empty() {
                info!("Pattern '{}' matched {} functions", pattern.name, matches.len());
                
                // Search for this dependency
                if let Some(dep_info) = self.search_for_dependency(&pattern, context).await? {
                    detected_deps.push(dep_info);
                    matched_functions.extend(matches);
                }
            }
        }

        // Step 2: Identify unmatched functions
        for function in &ffi_info.functions {
            if !matched_functions.contains(&function.name) {
                unmatched_functions.push(function.clone());
            }
        }

        // Step 3: If we have unmatched functions, try LLM assistance
        if !unmatched_functions.is_empty() && self.llm_client.is_some() {
            info!("Found {} unmatched functions, requesting LLM assistance", unmatched_functions.len());
            
            if let Some(additional_deps) = self.llm_assisted_detection(&unmatched_functions, context).await? {
                detected_deps.extend(additional_deps);
            }
        }

        Ok(detected_deps)
    }

    /// Find matches for a specific pattern
    fn find_pattern_matches(&self, pattern: &DependencyPattern, functions: &[crate::ffi::FfiFunction]) -> Vec<String> {
        let mut matches = Vec::new();

        for function in functions {
            // Check function name patterns
            for pattern_str in &pattern.function_patterns {
                if self.matches_pattern(&function.name, pattern_str) {
                    matches.push(function.name.clone());
                    break;
                }
            }
        }

        matches
    }

    /// Check if a string matches a pattern (supports wildcards)
    fn matches_pattern(&self, text: &str, pattern: &str) -> bool {
        if pattern.contains('*') {
            // Simple wildcard matching
            let parts: Vec<&str> = pattern.split('*').collect();
            if parts.len() == 2 {
                text.starts_with(parts[0]) && text.ends_with(parts[1])
            } else if parts.len() == 1 {
                if pattern.starts_with('*') {
                    text.ends_with(parts[0])
                } else {
                    text.starts_with(parts[0])
                }
            } else {
                // Complex patterns - could use regex here
                text.contains(&pattern.replace('*', ""))
            }
        } else {
            text == pattern || text.contains(pattern)
        }
    }

    /// Search for a dependency using multiple methods
    async fn search_for_dependency(&self, pattern: &DependencyPattern, context: &ToolContext) -> Result<Option<DependencyInfo>> {
        let mut candidates = Vec::new();

        // Method 1: Environment variables
        candidates.extend(self.search_env_vars(pattern)?);

        // Method 2: Common paths
        candidates.extend(self.search_common_paths(pattern)?);

        // Method 3: System package manager (pkg-config)
        if let Some(pkg_name) = &pattern.pkg_config_name {
            candidates.extend(self.search_pkg_config(pkg_name)?);
        }

        // Method 4: System-wide library search
        candidates.extend(self.system_wide_library_search(&pattern.link_libs)?);

        if candidates.is_empty() {
            return Ok(None);
        }

        // Validate candidates by checking for symbols
        let validated_candidates = self.validate_library_candidates(&candidates, pattern).await?;

        if validated_candidates.is_empty() {
            return Ok(None);
        }

        // If multiple candidates, we might need user input
        let chosen_candidate = if validated_candidates.len() > 1 {
            self.handle_multiple_candidates(&validated_candidates, pattern).await?
        } else {
            validated_candidates[0].clone()
        };

        // Build DependencyInfo from chosen candidate
        Ok(Some(self.build_dependency_info(pattern, &chosen_candidate)?))
    }

    /// LLM-assisted detection for unmatched functions
    async fn llm_assisted_detection(&self, unmatched_functions: &[crate::ffi::FfiFunction], context: &ToolContext) -> Result<Option<Vec<DependencyInfo>>> {
        let llm_client = self.llm_client.as_ref().unwrap();

        let function_names = unmatched_functions.iter()
            .map(|f| f.name.as_str())
            .take(20) // Limit to avoid huge prompts
            .collect::<Vec<_>>();

        let prompt = format!(
            r#"I'm analyzing C/C++ bindings and found these unmatched functions:

{}

Can you help identify what libraries these functions might come from? Please analyze the function names and suggest:

1. Possible library names (e.g., "openssl", "sqlite3", "opencv")
2. Typical function name patterns for those libraries 
3. Common header files that would contain these functions
4. Typical installation paths for these libraries

Respond in JSON format:
{{
    "suggestions": [
        {{
            "library_name": "example_lib",
            "confidence": 0.8,
            "reasoning": "Functions like 'example_*' typically come from libexample",
            "function_patterns": ["example_*", "ex_*"],
            "headers": ["example.h", "example/core.h"],
            "typical_paths": ["/usr/lib/libexample.so", "/usr/local/lib/libexample.so"]
        }}
    ]
}}

If you're not sure about some functions, you can ask the user for clarification by including:
{{
    "user_questions": [
        {{
            "functions": ["unknown_func1", "unknown_func2"],
            "question": "Do you know what library contains these functions? They don't match any common patterns I recognize."
        }}
    ]
}}
"#,
            function_names.join("\n- ")
        );

        let response = llm_client.generate("llama3.2", &prompt)?;
        
        // Parse LLM response and create new patterns
        if let Ok(llm_response) = serde_json::from_str::<LlmDependencyResponse>(&response) {
            let mut detected_deps = Vec::new();

            // Process LLM suggestions
            for suggestion in llm_response.suggestions {
                if suggestion.confidence > 0.5 {
                    // Create new pattern from LLM suggestion
                    let pattern = DependencyPattern {
                        name: suggestion.library_name.clone(),
                        source: PatternSource::LlmGenerated,
                        confidence: suggestion.confidence,
                        function_patterns: suggestion.function_patterns,
                        type_patterns: vec![],
                        header_indicators: suggestion.headers,
                        env_vars: vec![], // LLM would need to suggest these
                        common_paths: suggestion.typical_paths,
                        include_subpaths: vec!["include".to_string()],
                        lib_subpaths: vec!["lib".to_string(), "lib64".to_string()],
                        link_libs: vec![suggestion.library_name.clone()],
                        pkg_config_name: Some(suggestion.library_name.clone()),
                        created_at: chrono::Utc::now(),
                        success_count: 0,
                        failure_count: 0,
                    };

                    // Save the new pattern for future use
                    self.pattern_storage.save_pattern(&pattern)?;

                    // Try to find this dependency
                    if let Some(dep_info) = self.search_for_dependency(&pattern, context).await? {
                        detected_deps.push(dep_info);
                    }
                }
            }

            // Handle user questions
            if let Some(user_questions) = llm_response.user_questions {
                for question in user_questions {
                    if let Some(user_deps) = self.ask_user_about_functions(&question.functions, &question.question).await? {
                        detected_deps.extend(user_deps);
                    }
                }
            }

            if !detected_deps.is_empty() {
                return Ok(Some(detected_deps));
            }
        }

        Ok(None)
    }

    /// Ask user about unknown functions
    async fn ask_user_about_functions(&self, functions: &[String], question: &str) -> Result<Option<Vec<DependencyInfo>>> {
        // This would integrate with the CLI or UI to ask the user
        // For now, we'll use stdin/stdout
        
        println!("\nðŸ¤” Need your help with unknown functions!");
        println!("Functions: {}", functions.join(", "));
        println!("Question: {}", question);
        println!("Please enter the library name (or 'skip' to ignore): ");

        use std::io::{self, Write};
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let user_input = input.trim();

        if user_input == "skip" || user_input.is_empty() {
            return Ok(None);
        }

        // Create a new pattern based on user input
        let pattern = DependencyPattern {
            name: user_input.to_string(),
            source: PatternSource::UserProvided,
            confidence: 1.0, // User provided, so high confidence
            function_patterns: functions.iter().map(|f| format!("{}*", f.split('_').next().unwrap_or(f))).collect(),
            type_patterns: vec![],
            header_indicators: vec![format!("{}.h", user_input)],
            env_vars: vec![],
            common_paths: vec![
                format!("/usr/lib/lib{}.so", user_input),
                format!("/usr/local/lib/lib{}.so", user_input),
            ],
            include_subpaths: vec!["include".to_string()],
            lib_subpaths: vec!["lib".to_string(), "lib64".to_string()],
            link_libs: vec![user_input.to_string()],
            pkg_config_name: Some(user_input.to_string()),
            created_at: chrono::Utc::now(),
            success_count: 0,
            failure_count: 0,
        };

        // Save the pattern
        self.pattern_storage.save_pattern(&pattern)?;

        // Try to find this dependency
        if let Some(dep_info) = self.search_for_dependency(&pattern, &ToolContext::default()).await? {
            Ok(Some(vec![dep_info]))
        } else {
            Ok(None)
        }
    }

}

impl Tool for EnhancedDependencyDetectionTool {
    fn name(&self) -> &'static str {
        "enhanced_dependency_detection"
    }
    
    fn description(&self) -> &'static str {
        "Advanced dependency detection with multiple pattern sources, intelligent search, LLM assistance, and user interaction for unknown patterns"
    }
    
    fn requirements(&self) -> Vec<&'static str> {
        vec!["ffi_info"]
    }
    
    fn provides(&self) -> Vec<&'static str> {
        vec!["dependencies", "include_dirs", "lib_paths", "link_libs", "dependency_info"]
    }
    
    fn execute(&self, mut context: ToolContext) -> Result<ToolResult> {
        // This would be async in a real implementation
        let rt = tokio::runtime::Runtime::new()?;
        let detected_deps = rt.block_on(self.detect_dependencies(&context))?;
        
        // Update context with detected dependencies
        for dep in &detected_deps {
            // Add to dependencies list
            if !context.dependencies.contains(&dep.name) {
                context.dependencies.push(dep.name.clone());
            }
            
            // Add include directories
            for include_dir in &dep.include_dirs {
                if !context.include_dirs.contains(include_dir) {
                    context.include_dirs.push(include_dir.clone());
                }
            }
            
            // Add library paths
            for lib_path in &dep.lib_paths {
                if !context.lib_paths.contains(lib_path) {
                    context.lib_paths.push(lib_path.clone());
                }
            }
            
            // Add link libraries
            for link_lib in &dep.link_libs {
                if !context.link_libs.contains(link_lib) {
                    context.link_libs.push(link_lib.clone());
                }
            }
            
            // Update pattern statistics
            if let Some(ref pattern) = dep.pattern_used {
                let success = dep.user_choice.is_some() || !dep.library_candidates.is_empty();
                if let Err(e) = self.pattern_storage.update_pattern_stats(&pattern.name, success) {
                    warn!("Failed to update pattern stats: {}", e);
                }
            }
        }
        
        let message = if detected_deps.is_empty() {
            "No dependencies detected or resolved".to_string()
        } else {
            let mut msg = format!("Detected {} dependencies:", detected_deps.len());
            for dep in &detected_deps {
                msg.push_str(&format!("\n  - {}: {} libraries found", dep.name, dep.library_candidates.len()));
                if let Some(ref chosen) = dep.user_choice {
                    msg.push_str(&format!(" (using {})", chosen.path.display()));
                }
            }
            msg
        };
        
        let suggestions = if detected_deps.iter().any(|d| d.library_candidates.len() > 1) {
            vec!["Some dependencies had multiple library candidates. User choices have been recorded for future use.".to_string()]
        } else {
            vec![]
        };
        
        Ok(ToolResult {
            success: !detected_deps.is_empty(),
            message,
            updated_context: context,
            suggestions,
        })
    }
}

impl Default for ToolContext {
    fn default() -> Self {
        Self {
            source_path: PathBuf::new(),
            output_path: PathBuf::new(),
            lib_name: String::new(),
            headers: vec![],
            ffi_code: None,
            ffi_info: None,
            patterns: None,
            wrapper_code: None,
            dependencies: vec![],
            include_dirs: vec![],
            lib_paths: vec![],
            link_libs: vec![],
            build_errors: vec![],
        }
    }
}